# 本文档存储器以字节编址
# 本文档存储器以字节编址
# 本文档存储器以字节编址
j _start

.data
    .word 0,8,1,6,0xfffffff8,1,3,5,0   #编译成机器码时便器器会在前面多加个0，所以后面lw指令地址会多加4

_start:    

		addi $t0,$0,3       #t0=3
        addi $t1,$0,5   	#t1=5
		addi $t2,$0,1       #t2=1

        add  $s0,$t1,$t0  #s0=t1+t0=8  测试add指令 正确继续执行
        lw   $s1,12($0)  
        bne  $s1,$s0,_fail#不正确跳到fail 

        and  $s0,$t1,$t0  #s0=t1&t0=1  测试and指令 正确继续执行
        lw   $s1,16($0)  
        bne  $s1,$s0,_fail
 
        xor  $s0,$t1,$t0  #s0=t1^t0=6  测试xor指令 正确继续执行
        lw   $s1,20($0)  
        bne  $s1,$s0,_fail

        nor  $s0,$t1,$t0  #s0=t1 nor t0=0xfffffff8
        lw   $s1,24($0)  
        bne  $s1,$s0,_fail

        slt  $s0,$t0,$t1  #s0=1
        lw   $s1,28($0)  
        bne  $s1,$s0,_fail

        andi $s0,$t0,7  #s0=3
        lw   $s1,32($0)  
        bne  $s1,$s0,_fail

        ori  $s0,$t1,4  #s0=5
        lw   $s1,36($0)  
        bne  $s1,$s0,_fail
        
        sw   $t1,40($0)
        lw   $s1,40($0)
        beq  $t1,$s1,_sucess
                 
_fail:  
		sw   $0,8($0) #失败通过看存储器地址0x08里值，若为0则测试不通过，最初地址0x08里值为0
        j    _fail

_sucess: 
	sw   $t2,8($0)    #全部测试通过，存储器地址0x08里值为1
	j   _sucess       

					  #判断测试通过的条件是最后存储器地址0x08里值为1，说明全部通过测试








t0=8
s0=16



00100010001100010000000000000001
00000000000000001000000000100000
10001101001101110000000000000000





10101101010101110000000000000000
00000010111110000101100000101010
10001101010110000000000000000000
             
                      
      add $s0, $zero,$zero            #相当于变量i，初始化i = 0；                           00000000000000001000000000100000      00008020
external_loop:
      add $s1, $zero, $zero           #相当于变量j，每次进入内部要置为0                         00000000000000001000100000100000    00008820
internal_loop:

	  add $t1, $s1, $zero                                                                      00000010001000000100100000100000   02204820
	  lw  $s7, 0($t1)              #相当于array[j]                                              10001101001101110000000000000000    8d370000

	  addi $t2, $s1, 1                                                                         00100010001010100000000000000001     222a0001

	  lw  $s8, 0($t2)              #相当于array[j+1]                                            10001101010110000000000000000000    8d580000
	  slt $t3,  $s7,  $s8          #判断是否array[j] < array[j+1]                               000000 10111 11000 01011 00000 101010        2f8582a

      beq  $t3,$0,exit             #若array[j]<array[j+1],t3 = 1；                                 00010001011000000000000000000010             11600002

                                 #若t3 == 0,则跳转到exit,无需交换


	  sw $s7, 0($t2)               #交换                                                        10101101010101110000000000000000            ad570000
	  sw $s8, 0($t1)                                                                            10101101001110000000000000000000            ad380000
exit:
      addi $s1, $s1, 1             #j++                                                         00100010001100010000000000000001            22310001
	  addi $t4, $zero, 9                                                                        00100000000011000000000000001001            200c0009
	  sub  $t5, $t4, $s0                                                                        00000001100100000110100000100010            01906822
	  slt  $t6, $s1, $t5                                                                        00000010001011010111000000101010            022d702a
	  beq $t6, $1, internal_loop      #判断j是否小于9-i,如果是的话，跳转internal_loop              00010001110000010000000000000011            11c10003

	  addi $s0, $s0, 1             #i++                                                         00100010000100000000000000000001            22100001
	  slti $t6, $s0, 9                                                                          00101010000011100000000000001001            2a0e0009
	  beq $t6, $1, external_loop      #判断是否i是否小于9                                         00010001110000010000000000000001            11c10001

jump:
        j    internal_loop                                                                      00001000000000000000000000000010            8000002
        j    external_loop                                                                      00001000000000000000000000000001            8000001      



00008020
00008820
02204820
8d370000
222a0001
8d580000
2f8582a
11600002
ad570000
ad380000
22310001
200c0009
01906822
022d702a
11c10003
22100001
2a0e0009
11c10001
08000002
08000001